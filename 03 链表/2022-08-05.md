### 链表（Linked List）

- [链表的接口设计](#_16)
- [单向链表（SingleLinkedList）](#SingleLinkedList_138)
- - [获取元素 – get\(\)](#__get_160)
  - [清空元素 – clear\(\)](#__clear_179)
  - [添加元素 – add\(int index, E element\)](#__addint_index_E_element_190)
  - [删除元素 – remove\(int index\)](#__removeint_index_211)
  - [单向链表完整源码](#_234)
- [带虚拟头结点的单向链表](#_374)
- [动态数组、链表复杂度分析](#_499)
- [双向链表（LinkedList）](#LinkedList_503)
- - [双向链表 – get\(int index\)](#__getint_index_548)
  - [双向链表 – add\(int index, E element\)](#__addint_index_E_element_575)
  - [双向链表 – remove\(int index\)](#__removeint_index_606)
  - [双向链表完整源码](#_632)
- [双向链表 vs 单向链表](#_vs__807)
- [双向链表 vs 动态数组](#_vs__814)
- [练习题](#_824)
- - [练习 – 删除链表中的节点](#___825)
  - [练习 – 反转一个链表（递归、非递归解法）](#___846)
  - [练习 – 判断一个链表是否有环（快慢指针）](#___899)

> **数据结构与算法笔记目录**：[《恋上数据结构》 笔记目录](https://blog.csdn.net/weixin_43734095/article/details/104847976)

> **想加深 Java 基础推荐看这个**： [Java 强化笔记目录](https://blog.csdn.net/weixin_43734095/article/details/105591119)

动态数组有个明显的缺点：

- 可能会造成内存空间的大量浪费。

能否用到多少就申请多少内存？

- 链表可以办到这一点

**链表**是一种**链式存储**的线性表，所有元素的**内存地址不一定是连续的**;

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501101927719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)

# 链表的接口设计

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501103207445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)  
由于**链表的大部分接口和动态数组一致**，我们抽取出一个共同的 `List` **接口**；

```java
package com.mj;

public interface List<E> {
	static final int ELEMENT_NOT_FOUND = -1;
	/**
	 * 清除所有元素
	 */
	void clear();

	/**
	 * 元素的数量
	 * @return
	 */
	int size();

	/**
	 * 是否为空
	 * @return
	 */
	boolean isEmpty();

	/**
	 * 是否包含某个元素
	 * @param element
	 * @return
	 */
	boolean contains(E element);

	/**
	 * 添加元素到尾部
	 * @param element
	 */
	void add(E element);

	/**
	 * 获取index位置的元素
	 * @param index
	 * @return
	 */
	E get(int index);

	/**
	 * 设置index位置的元素
	 * @param index
	 * @param element
	 * @return 原来的元素ֵ
	 */
	E set(int index, E element);

	/**
	 * 在index位置插入一个元素
	 * @param index
	 * @param element
	 */
	void add(int index, E element);

	/**
	 * 删除index位置的元素
	 * @param index
	 * @return
	 */
	E remove(int index);

	/**
	 * 查看元素的索引
	 * @param element
	 * @return
	 */
	int indexOf(E element);
}
```

再将一些通用的字段与方法放到一个抽象类中，无论是**动态数组**还是**链表**都**只需要继承这个抽象类**即可。

```java
package com.mj;

public abstract class AbstractList<E> implements List<E>{
	
	protected int size;
	
	// 下标越界抛出的异常
	protected void outOfBounds(int index) {
		throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size);
	}
	// 检查下标越界(不可访问或删除size位置)
	protected void rangeCheck(int index){
		if(index < 0 || index >= size){
			outOfBounds(index);
		}
	}
	// 检查add()的下标越界(可以在size位置添加元素)
	protected void rangeCheckForAdd(int index) {
		if (index < 0 || index > size) {
			outOfBounds(index);
		}
	}
	
	@Override
	public boolean contains(E element) {
		return indexOf(element)!=ELEMENT_NOT_FOUND;
	}
	
	@Override
	public int size() {
		return size;
	}

	@Override
	public boolean isEmpty() {
		return size == 0;
	}
	
	@Override
	public void add(E element) {
		add(size, element);
	}

}
```

# 单向链表（SingleLinkedList）

单向链表的结构如下图所示：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501105046819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)

```java
public class SingleLinkedList<E> extends AbstractList<E> {

	private Node<E> first;

	// 链表中的节点
	private static class Node<E> {
		E element; // 节点元素
		Node<E> next; // 节点指向下一个节点

		public Node(E element, Node<E> next) {
			this.element = element;
			this.next = next;
		}
	}
	
}
```

## 获取元素 – get\(\)

```java
@Override
public E get(int index) {
	return node(index).element;
}
/**
 * 根据索引找到节点
 */
private Node<E> node(int index) {
	rangeCheck(index);
	Node<E> node = first;
	for (int i = 0; i < index; i++) {
		node = node.next;
	}
	return node;
}
```

## 清空元素 – clear\(\)

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020050110461644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)

 -    `next` 不需要设置为 `null`，因为 `first` 指向了 `null`，后面的 `Node` 没有被指向，在 Java 中会自动被垃圾回收。

```java
@Override
public void clear() {
	size = 0;
	first = null;
}
```

## 添加元素 – add\(int index, E element\)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501104956727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)  
添加元素尤其要注意 0 位置，给空链表添加第一个节点是个特殊情况：

```java
@Override
public void add(int index, E element) {
	/*
	* 最好：O(1)
	* 最坏：O(n)
	* 平均：O(n)
	*/
	rangeCheckForAdd(index);
	if(index == 0){ // 给空链表添加第一个元素的情况
		first = new Node<>(element, first);
	}else{
		Node<E> prev = node(index - 1);
		prev.next = new Node<>(element, prev.next);
	}
	size++;
}
```

## 删除元素 – remove\(int index\)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501110115103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)

```java
@Override
public E remove(int index) {
	/*
	* 最好：O(1)
	* 最坏：O(n)
	* 平均：O(n)
	*/
	rangeCheck(index);
	Node<E> node = first;
	if (index == 0) { // 删除第一个元素是特殊情况
		first = first.next;
	} else {
		Node<E> prev = node(index - 1); // 找到前一个元素
		node = prev.next; // 要删除的元素
		prev.next = node.next; // 删除元素
	}
	size--;
	return node.element;
}
```

## 单向链表完整源码

```java
package com.mj.single;

import com.mj.AbstractList;

/**
 * 单向链表
 * @author yusael
 */
public class SingleLinkedList<E> extends AbstractList<E> {

	private Node<E> first;

	// 链表中的节点
	private static class Node<E> {
		E element; // 节点元素
		Node<E> next; // 节点指向下一个节点

		public Node(E element, Node<E> next) {
			this.element = element;
			this.next = next;
		}
	}

	/**
	 * 根据索引找到节点对象
	 */
	private Node<E> node(int index) {
		rangeCheck(index);
		Node<E> node = first;
		for (int i = 0; i < index; i++) {
			node = node.next;
		}
		return node;
	}

	@Override
	public void clear() {
		size = 0;
		first = null;
	}

	@Override
	public E get(int index) {
		/*
		 * 最好:O(1)
		 * 最坏:O(n)
		 * 平均:O(n)
		 */
		return node(index).element;
	}

	@Override
	public E set(int index, E element) {
		/*
		 * 最好:O(1)
		 * 最坏:O(n)
		 * 平均:O(n)
		 */
		E old = node(index).element;
		node(index).element = element;
		return old;
	}

	@Override
	public void add(int index, E element) {
		/*
		 * 最好：O(1)
		 * 最坏：O(n)
		 * 平均：O(n)
		 */
		rangeCheckForAdd(index);
		if (index == 0) { // 给空链表添加第一个元素的情况
			first = new Node<>(element, first);
		} else {
			Node<E> prev = node(index - 1);
			prev.next = new Node<>(element, prev.next);
		}
		size++;
	}

	@Override
	public E remove(int index) {
		/*
		 * 最好：O(1)
		 * 最坏：O(n)
		 * 平均：O(n)
		 */
		rangeCheck(index);
		Node<E> node = first;
		if (index == 0) { // 删除第一个元素是特殊情况
			first = first.next;
		} else {
			Node<E> prev = node(index - 1); // 找到前一个元素
			node = prev.next; // 要删除的元素
			prev.next = node.next; // 删除元素
		}
		size--;
		return node.element;
	}

	@Override
	public int indexOf(E element) {
		// 有个注意点, 如果传入元素为null, 则不能调用equals方法, 否则会空指针
		// 因此需要对元素是否为null做分别处理
		if (element == null) {
			Node<E> node = first;
			for (int i = 0; i < size; i++) {
				if (node.element == null) return i;
				node = node.next;
			}
		} else {
			Node<E> node = first;
			for (int i = 0; i < size; i++) {
				if (node.element.equals(element)) return i;
				node = node.next;
			}
		}
		return ELEMENT_NOT_FOUND;
	}

	@Override
	public String toString() {
		StringBuilder string = new StringBuilder();
		string.append("[size=").append(size).append(", ");
		Node<E> node = first;
		for (int i = 0; i < size; i++) {
			if (i != 0) {
				string.append(", ");
			}
			string.append(node.element);
			node = node.next;
		}
		string.append("]");
		return string.toString();
	}

}
```

# 带虚拟头结点的单向链表

有时候为了让代码更加精简，统一所有节点的处理逻辑，可以在最前面增加一个**虚拟的头结点（不存储数据）**。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501112026417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)  
带虚拟头结点的单向链表与普通单向链表代码类似：但是 `add`、`reomove` 略有不同；

```java
package com.mj.single;

import com.mj.AbstractList;

/**
 * 增加一个虚拟头结点
 * @author yusael
 */
public class SingleLinkedList2<E> extends AbstractList<E> {

	private Node<E> first;

	//**********************************
	public SingleLinkedList2() { // 初始化一个虚拟头结点
		first = new Node<>(null, null);
	};
	//**********************************

	private static class Node<E> {
		E element;
		Node<E> next;

		public Node(E element, Node<E> next) {
			this.element = element;
			this.next = next;
		}
	}

	@Override
	public void clear() {
		size = 0;
		first = null;
	}

	@Override
	public E get(int index) {
		return node(index).element;
	}

	@Override
	public E set(int index, E element) {
		E old = node(index).element;
		node(index).element = element;
		return old;
	}

	@Override
	public void add(int index, E element) {
		rangeCheckForAdd(index);
		Node<E> prev = (index == 0) ? first : node(index - 1);
		prev.next = new Node<>(element, prev.next);
		size++;
	}

	@Override
	public E remove(int index) {
		rangeCheck(index);

		Node<E> prev = (index == 0) ? first : node(index - 1);
		Node<E> node = prev.next;
		prev.next = node.next;

		size--;
		return prev.element;
	}

	@Override
	public int indexOf(E element) {
		// 有个注意点, 如果传入元素为null, 则不能调用equals方法, 否则会空指针
		// 因此需要对元素是否为null做分别处理
		if (element == null) {
			Node<E> node = first;
			for (int i = 0; i < size; i++) {
				if (node.element == null) return i;
				node = node.next;
			}
		} else {
			Node<E> node = first;
			for (int i = 0; i < size; i++) {
				if (node.element.equals(element)) return i;
				node = node.next;
			}
		}
		return ELEMENT_NOT_FOUND;
	}
	
	/**
	 * 根据索引找到节点
	 * 
	 * @param index
	 * @return
	 */
	private Node<E> node(int index) {
		rangeCheck(index);
		Node<E> node = first.next;
		for (int i = 0; i < index; i++) {
			node = node.next;
		}
		return node;
	}

	@Override
	public String toString() {
		StringBuilder string = new StringBuilder();
		string.append("[size=").append(size).append(", ");
		Node<E> node = first.next;
		for (int i = 0; i < size; i++) {
			if (i != 0) {
				string.append(", ");
			}
			string.append(node.element);
			node = node.next;
		}
		string.append("]");
		return string.toString();
	}

}
```

# 动态数组、链表复杂度分析

数组的**随机访问速度**非常快：`elements[n]` 的效率与 n 是多少无关；  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501114048443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)

# 双向链表（LinkedList）

双向链表可以提升链表的综合性能；  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501114320332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)  
双向链表**只有一个元素**的情况：`first`、`last` 指向同一个节点  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501114458482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)

```java
/**
 * 双向链表
 * @author yusael
 */
public class LinkedList<E> extends AbstractList<E> {

	private Node<E> first;
	private Node<E> last;

	private static class Node<E> {
		E element;
		Node<E> prev;
		Node<E> next;

		public Node(Node<E> prev, E element, Node<E> next) {
			this.prev = prev;
			this.element = element;
			this.next = next;
		}
		@Override
		public String toString(){
			StringBuilder sb = new StringBuilder();
			if(prev != null){
				sb.append(prev.element);
			}else{
				sb.append("null");
			}
			sb.append("_").append(element).append("_");
			if(next != null){
				sb.append(next.element);
			}else{
				sb.append("null");
			}
			
			return sb.toString();
		}
	}
}
```

## 双向链表 – get\(int index\)

```java
@Override
public E get(int index) {
	return node(index).element;
}
/**
 * 根据索引找到节点
 */
private Node<E> node(int index) {
	rangeCheck(index);
	
	if (index < (size >> 1)) { // 索引小于一半从前往后找
		Node<E> node = first;
		for (int i = 0; i < index; i++) {
			node = node.next;
		}
		return node;
	} else { // 索引大于一半从后往前找
		Node<E> node = last;
		for (int i = size - 1; i > index; i--) {
			node = node.prev;
		}
		return node;
	}
}
```

## 双向链表 – add\(int index, E element\)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501114815705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)

```java
@Override
public void add(int index, E element) {
	rangeCheckForAdd(index);

	// size == 0
	// index == 0
	if (index == size) { // 往最后面添加元素
		Node<E> oldLast = last;
		last = new Node<>(oldLast, element, null);
		if (oldLast == null) { // 这是链表添加的第一个元素
			first = last;
		} else {
			oldLast.next = last;
		}
	} else { // 正常添加元素
		Node<E> next = node(index);
		Node<E> prev = next.prev;
		Node<E> node = new Node<>(prev, element, next);
		next.prev = node;
		if (prev == null) { // index == 0
			first = node;
		} else {
			prev.next = node;
		}
	}
	size++;
}
```

## 双向链表 – remove\(int index\)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501115858618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)

```java
@Override
public E remove(int index) {
	rangeCheck(index);

	Node<E> node = node(index);
	Node<E> prev = node.prev;
	Node<E> next = node.next;
	
	if (prev == null) { // index == 0
		first = next;
	} else {
		prev.next = next;
	}
	
	if (next == null) { // index == size - 1
		last = prev;
	} else {
		next.prev = prev;
	}
	size--;
	return node.element;
}
```

## 双向链表完整源码

```java
package com.mj;

import com.mj.AbstractList;

/**
 * 双向链表
 * @author yusael
 */
public class LinkedList<E> extends AbstractList<E> {

	private Node<E> first;
	private Node<E> last;

	private static class Node<E> {
		E element;
		Node<E> prev; // 指向前驱节点
		Node<E> next; // 指向后继节点

		public Node(Node<E> prev, E element, Node<E> next) {
			this.prev = prev;
			this.element = element;
			this.next = next;
		}
		@Override
		public String toString(){
			StringBuilder sb = new StringBuilder();
			if(prev != null){
				sb.append(prev.element);
			}else{
				sb.append("null");
			}
			sb.append("_").append(element).append("_");
			if(next != null){
				sb.append(next.element);
			}else{
				sb.append("null");
			}
			
			return sb.toString();
		}
	}
	
	@Override
	public void clear() {
		size = 0;
		first = null;
		last = null;
	}

	@Override
	public E get(int index) {
		return node(index).element;
	}

	@Override
	public E set(int index, E element) {
		Node<E> node = node(index);
		E old = node.element;
		node.element = element;
		return old;
	}

	@Override
	public void add(int index, E element) {
		rangeCheckForAdd(index);

		// size == 0
		// index == 0
		if (index == size) { // 往最后面添加元素
			Node<E> oldLast = last;
			last = new Node<>(oldLast, element, null);
			if (oldLast == null) { // 这是链表添加的第一个元素
				first = last;
			} else {
				oldLast.next = last;
			}
		} else { // 正常添加元素
			Node<E> next = node(index);
			Node<E> prev = next.prev;
			Node<E> node = new Node<>(prev, element, next);
			next.prev = node;
			if (prev == null) { // index == 0
				first = node;
			} else {
				prev.next = node;
			}
		}
		size++;
	}

	@Override
	public E remove(int index) {
		rangeCheck(index);

		Node<E> node = node(index);
		Node<E> prev = node.prev;
		Node<E> next = node.next;
		
		if (prev == null) { // index == 0
			first = next;
		} else {
			prev.next = next;
		}
		
		if (next == null) { // index == size - 1
			last = prev;
		} else {
			next.prev = prev;
		}
		size--;
		return node.element;
	}

	@Override
	public int indexOf(E element) {
		if (element == null) {
			Node<E> node = first;
			for (int i = 0; i < size; i++) {
				if (node.element == element) return i;
				node = node.next;
			}
		} else {
			Node<E> node = first;
			for (int i = 0; i < size; i++) {
				if (node.element.equals(element)) return i;
				node = node.next;
			}
		}
		return ELEMENT_NOT_FOUND;
	}

	/**
	 * 根据索引找到节点
	 * 
	 * @param index
	 * @return
	 */
	private Node<E> node(int index) {
		rangeCheck(index);
		
		if (index < (size >> 1)) { // 索引小于一半从前往后找
			Node<E> node = first;
			for (int i = 0; i < index; i++) {
				node = node.next;
			}
			return node;
		} else { // 索引大于一半从后往前找
			Node<E> node = last;
			for (int i = size - 1; i > index; i--) {
				node = node.prev;
			}
			return node;
		}
	}
	
	@Override
	public String toString() {
		StringBuilder string = new StringBuilder();
		string.append("[size=").append(size).append(", ");
		Node<E> node = first;
		for (int i = 0; i < size; i++) {
			if (i != 0) {
				string.append(", ");
			}
			string.append(node);
			node = node.next;
		}
		string.append("]");
		return string.toString();
	}

}
```

# 双向链表 vs 单向链表

粗略对比一下**删除的操作数量**：操作数量缩减了近一半  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501120225365.png)  
有了双向链表，单向链表是否就没有任何用处了？

- 并非如此，在哈希表的设计中就用到了单链表
- 至于原因，在哈希表章节中会讲到

# 双向链表 vs 动态数组

**动态数组**：开辟、销毁内存空间的次数相对较少，但可能造成内存空间浪费（可以通过缩容解决）  
**双向链表**：开辟、销毁内存空间的次数相对较多，但不会造成内存空间的浪费

- 如果频繁在**尾部进行添加、删除操作**，动态数组、双向链表均可选择
- 如果频繁在**头部进行添加、删除操作**，建议选择使用双向链表
- 如果有频繁的 **（在任意位置）添加、删除操作**，建议选择使用双向链表
- 如果有频繁的**查询操作**（随机访问操作），建议选择使用动态数组

# 练习题

## 练习 – 删除链表中的节点

237\_删除链表中的节点：<https://leetcode-cn.com/problems/delete-node-in-a-linked-list/>  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501121452919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501121517752.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501121547748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```

## 练习 – 反转一个链表（递归、非递归解法）

206\_反转链表：<https://leetcode-cn.com/problems/reverse-linked-list/>  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501122400147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)  
**递归解法**：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501124029367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501124042933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501124100628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
    	if(head == null) return null; // 空链表
    	if(head.next == null) return head; // 只有一个节点
    	ListNode newHead = reverseList(head.next);
    	head.next.next = head; // newHead->1->2->3->4->5->null
    	head.next = null;
    	return newHead;
    }
}
```

**非递归解法** \- 头插法：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501123954523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode newHead = null;
        while (head != null) {
            ListNode tmp = head.next;
            head.next = newHead;
            newHead = head;
            head = tmp;
        }
        return newHead;
    }
}
```

## 练习 – 判断一个链表是否有环（快慢指针）

141\_环形链表：<https://leetcode-cn.com/problems/linked-list-cycle/>  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501124408811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501124421402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501124431830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)  
快慢指针解法：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501124504847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70)

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null) return false;
        ListNode slow = head;
        ListNode fast = head.next; // 快指针每次都比慢指针快一步(包括开始)
        while (fast != null && fast.next != null) {
            if (slow.val == fast.val) return true;
            slow = slow.next;
            fast = fast.next.next;
        }
        return false;
    }
}
```